#pragma kernel CreateWidth

#define NUM_THREAD_X 16

#include "GPUTrailVariables.compute"

int _InputNum;
int _TotalInputIdx;
uint _BufferSize;

StructuredBuffer<Node> inputBuffer;
RWStructuredBuffer<Node> pointBuffer;
RWStructuredBuffer<Vertex> vertexBuffer;


// idx must 0~_BufferSize-1
int GetInputBufIdx(int idx)
{
	//今回のInputに含まれるIdx
	int inputFirst = (_TotalInputIdx - _InputNum + 1) % _BufferSize;
	int idxWithOffset = idx + ((idx < inputFirst) ? _BufferSize : 0);

	return ((inputFirst <= idxWithOffset) && (idxWithOffset < (inputFirst + _InputNum)))
	? idxWithOffset - inputFirst
	: -1;
}

Node GetNode(int idx)
{
	int inputBufIdx = GetInputBufIdx(idx);
	if ( inputBufIdx >= 0 )
	{
		return inputBuffer[inputBufIdx]; 
	}

	return pointBuffer[idx];
}

[numthreads(NUM_THREAD_X,1,1)]
void CreateWidth (uint3 id : SV_DispatchThreadID)
{
	int idx = id.x;
	if ( idx < min((int)_BufferSize, _TotalInputIdx+1) )
	{
		int inputIdxLast = _TotalInputIdx % _BufferSize;
		int inputBufIdx = GetInputBufIdx(idx);
		if ( inputBufIdx >= 0 )
		{
			pointBuffer[idx] = inputBuffer[inputBufIdx];
			if ( _TotalInputIdx == 0 ) return; // 最低2個以上（_TotalInputIdx>0 必要）
		}


		Vertex v0 = {float3(0,0,0), float2(-1,-1)};
		Vertex v1 = {float3(0,0,0), float2(-1,-1)};

		Node pt = GetNode(idx);
		float3 pos = pt.pos;

		float3 dirPrev = float3(0,0,0);
		float3 dirNext = float3(0,0,0);
		{
			int prevIdx = (idx==0) ? _BufferSize-1 : idx-1;
			bool prevEnable = prevIdx != inputIdxLast;
			if ( prevEnable )
			{
				Node ptPrev = GetNode(prevIdx); //pointBuffer[prevIdx];
				dirPrev = normalize(pos - ptPrev.pos);
			}

			int nextIdx = (idx+1) % _BufferSize;
			bool nextEnable = idx != inputIdxLast;
			if ( nextEnable )
			{
				// inputがまだpointBufferに書き込まれてない可能性を考えて直でinputBufferを見る
				Node ptNext = GetNode(nextIdx); //(nextIdx==inputIdxLast) ? inputBuffer[0].pos : pointBuffer[nextIdx].pos;
				dirNext = normalize(ptNext.pos - pos);
			}
		}


		float rate = _Life <= 0 ? 1 : 1 - ((_Time - pt.time) / _Life);

		float3 dir = normalize(dirPrev + dirNext);
		//float3 dir = float3(0,1,0);

		float3 toCameraDir = normalize(_CameraPos - pos);
		float3 right = normalize(cross(dir, toCameraDir)) * lerp(_EndWidth, _StartWidth, rate) * 0.5f;

		v0.pos = pos - right;
		v0.uv = float2(rate, 0);

		v1.pos = pos + right;
		v1.uv = float2(rate, 1);

		int drawIdx = inputIdxLast - (int)idx;
		drawIdx = drawIdx < 0 ? (int)_BufferSize + drawIdx : drawIdx;


		uint vId = drawIdx * 2;
		vertexBuffer[vId] = v0;
		vertexBuffer[vId+1] = v1;
	}
}
