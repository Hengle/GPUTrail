#pragma kernel CreateWidth
#pragma kernel CreatePolygon

#define NUM_THREAD_X 16

struct Point
{
    float3 pos;
    float time;
};

struct Vertex
{
    float3 pos;
    float2 uv;
	float4 color;
};


float3 _CameraPos;
float _Life;
uint _TotalInputIdx;
uint _BufferSize;
float _Time;
float _StartWidth;
float _EndWidth;
float4 _StartColor;
float4 _EndColor;

StructuredBuffer<Point> inputBuffer;
RWStructuredBuffer<Point> pointBuffer;
RWStructuredBuffer<Vertex> vertexBuffer;



[numthreads(NUM_THREAD_X,1,1)]
void CreateWidth (uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	if ( idx < min(_BufferSize, _TotalInputIdx+1) )
	{
		uint inputIdx = _TotalInputIdx % _BufferSize;
		if ( idx == inputIdx )
		{
			pointBuffer[idx] = inputBuffer[0];
			if ( _TotalInputIdx == 0 ) return;
		}


		Vertex v0 = {float3(0,0,0), float2(-1,-1), float4(0,0,0,0)};
		Vertex v1 = {float3(0,0,0), float2(-1,-1), float4(0,0,0,0)};
		{
			Point pt = pointBuffer[idx];
			float3 pos = pt.pos;

			float3 dirPrev = float3(0,0,0);
			float3 dirNext = float3(0,0,0);
			{
				uint prevIdx = (idx==0) ? _BufferSize-1 : idx-1;
				bool prevEnable = prevIdx != inputIdx;
				if ( prevEnable )
				{
					Point ptPrev = pointBuffer[prevIdx];
					dirPrev = normalize(pos - ptPrev.pos);
				}

				uint nextIdx = (idx+1)>=_BufferSize ? 0 : idx+1;
				bool nextEnable = idx != inputIdx;
				if ( nextEnable )
				{
					// inputがまだpointBufferに書き込まれてない可能性を考えて直でinputBufferを見る
					float3 nextPos = (nextIdx==inputIdx) ? inputBuffer[0].pos : pointBuffer[nextIdx].pos;
					dirNext = normalize(nextPos - pos);
				}
			}


			float rate = _Life <= 0 ? 1 : 1 - ((_Time - pt.time) / _Life);

			float3 dir = normalize(dirPrev + dirNext);

			float3 toCameraDir = normalize(_CameraPos - pos);
			float3 rightDir = normalize(cross(dir, toCameraDir));
			float  rightLength = lerp(_EndWidth, _StartWidth, rate) * 0.5f;
			float3 right = rightDir * rightLength;

			float4 col = lerp(_EndColor, _StartColor, rate);

			v0.pos = pos - right;
			v0.uv = float2(rate, 0);
			v0.color = col;

			v1.pos = pos + right;
			v1.uv = float2(rate, 1);
			v1.color = col;
		}

		int drawIdx = (int)inputIdx - (int)idx;
		drawIdx = drawIdx < 0 ? (int)_BufferSize + drawIdx : drawIdx;


		uint vId = drawIdx * 6;
		vertexBuffer[vId] = v0;
		vertexBuffer[vId+1] = v1;
	}
}


[numthreads(NUM_THREAD_X,1,1)]
void CreatePolygon (uint3 id : SV_DispatchThreadID)
{
	if ( id.x < min(_BufferSize, _TotalInputIdx) )
	{
		uint vId = id.x * 6;
		uint vIdNext = ((id.x+1)%_BufferSize) * 6;
		//vertexBuffer[vId].pos = v0;
		//vertexBuffer[vId+1].pos = v1;
		vertexBuffer[vId+2] = vertexBuffer[vIdNext];

		vertexBuffer[vId+3] = vertexBuffer[vIdNext];
		vertexBuffer[vId+4] = vertexBuffer[vId+1];
		vertexBuffer[vId+5] = vertexBuffer[vIdNext+1];
	}
}
