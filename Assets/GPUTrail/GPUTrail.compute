#pragma kernel CreateWidth
#pragma kernel CreatePolygon

#define NUM_THREAD_X 16

struct Point
{
    float3 pos;
    float time;
};

struct Vertex
{
    float3 pos;
    float2 uv;
	float4 color;
};


float3 _CameraPos;
float _Life;
float _Width;
uint _TotalInputIdx;
uint _BufferSize;
float _Time;

StructuredBuffer<Point> inputBuffer;
RWStructuredBuffer<Point> pointBuffer;
RWStructuredBuffer<Vertex> vertexBuffer;


[numthreads(NUM_THREAD_X,1,1)]
void CreateWidth (uint3 id : SV_DispatchThreadID)
{
	uint idx = id.x;
	if ( idx < min(_BufferSize, _TotalInputIdx+1) )
	{
		uint inputIdx = _TotalInputIdx % _BufferSize;
		if ( idx == inputIdx )
		{
			pointBuffer[idx] = inputBuffer[0];
			if ( _TotalInputIdx == 0 ) return;
		}


		Vertex v0 = {float3(0,0,0), float2(-1,-1), float4(0,0,0,0)};
		Vertex v1 = {float3(0,0,0), float2(-1,-1), float4(0,0,0,0)};

		Point pt = pointBuffer[idx];
		float3 pos = pt.pos;

		float3 dirPrev = float3(0,0,0);
		float3 dirNext = float3(0,0,0);

		uint prevIdx = (idx==0) ? _BufferSize-1 : idx-1;
		bool prevEnable = prevIdx != inputIdx;
		if ( prevEnable )
		{
			Point ptPrev = pointBuffer[prevIdx];
			dirPrev = normalize(pos - ptPrev.pos);
		}

		uint nextIdx = (idx+1)>=_BufferSize ? 0 : idx+1;
		bool nextEnable = idx != inputIdx;
		if ( nextEnable )
		{
			// inputがまだpointBufferに書き込まれてない可能性を考えて直でinputBufferを見る
			float3 nextPos = (nextIdx==inputIdx) ? inputBuffer[0].pos : pointBuffer[nextIdx].pos;
			dirNext = normalize(nextPos - pos);
		}

		float3 dir = normalize(dirPrev + dirNext);

		float3 toCameraDir = normalize(_CameraPos - pos);
		float3 right = normalize(cross(dir, toCameraDir)) * _Width * 0.5f;


		float rate = _Life <= 0 ? 1 : 1 - ((_Time - pt.time) / _Life);
		//float r = idx / (_BufferSize-1.0);
		float r = (idx == _BufferSize-1) ? 1 : 0;
		float b = (idx == 1) ? 1 : 0;

		v0.pos = pos - right;
		v0.uv = float2(rate, 0);
		v0.color = float4(r, b,1,1);

		v1.pos = pos + right;
		v1.uv = float2(rate, 1);
		v1.color = float4(r, b,1,1);

		int drawIdx = (int)inputIdx - (int)idx;
		drawIdx = drawIdx < 0 ? (int)_BufferSize + drawIdx : drawIdx;


		uint vId = drawIdx * 6;
		vertexBuffer[vId] = v0;
		vertexBuffer[vId+1] = v1;
	}
}


[numthreads(NUM_THREAD_X,1,1)]
void CreatePolygon (uint3 id : SV_DispatchThreadID)
{
	if ( id.x < min(_BufferSize, _TotalInputIdx) )
	{
		uint vId = id.x * 6;
		uint vIdNext = ((id.x+1)%_BufferSize) * 6;
		//vertexBuffer[vId].pos = v0;
		//vertexBuffer[vId+1].pos = v1;
		vertexBuffer[vId+2] = vertexBuffer[vIdNext];

		vertexBuffer[vId+3] = vertexBuffer[vIdNext];
		vertexBuffer[vId+4] = vertexBuffer[vId+1];
		vertexBuffer[vId+5] = vertexBuffer[vIdNext+1];
	}
}
